package stats_test

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"testing"

	"github.com/HazelnutParadise/insyra"
	"github.com/HazelnutParadise/insyra/stats"
	"gonum.org/v1/gonum/mat"
)

func TestDebugRotmat(t *testing.T) {
	// Embedded SPSS target
	var spssTargetJSON = `{
	  "loadings": [
		[0.356343, 0.761905, -0.016447],
		[0.410697, 0.569859, 0.255471],
		[0.503369, 0.533348, 0.07185],
		[0.695961, 0.112845, -0.485805],
		[0.731736, -0.294728, -0.443574],
		[0.681167, -0.001737, -0.311898],
		[0.516291, -0.160115, 0.611136],
		[0.684009, -0.33903, 0.28828],
		[0.652246, -0.167228, 0.320202]
	  ],
	  "rotmat": [
		[0.987413, 0.149994, 0.050166],
		[-0.132469, 0.989933, -0.049839],
		[0.017541, -0.037383, -0.999147]
	  ],
	  "Phi": [
		[1.0, 0.015183, 0.03841],
		[0.015183, 1.0, -0.010466],
		[0.03841, -0.010466, 1.0]
	  ]
	}`

	type spssRef struct {
		Loadings [][]float64 `json:"loadings"`
		Rotmat   [][]float64 `json:"rotmat"`
		Phi      [][]float64 `json:"Phi"`
	}

	var ref spssRef
	if err := json.Unmarshal([]byte(spssTargetJSON), &ref); err != nil {
		t.Fatalf("failed to parse SPSS reference: %v", err)
	}

	// Embedded CSV data (complete dataset)
	csvData := `x1,x2,x3,x4,x5,x6,x7,x8,x9
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,2.0,2.0,2.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,4.0,3.0,4.0,3.0,3.0
3.0,2.0,3.0,3.0,4.0,3.0,2.0,3.0,2.0
3.0,3.0,3.0,3.0,4.0,3.0,3.0,3.0,3.0
4.0,3.0,3.0,2.0,2.0,2.0,3.0,2.0,2.0
3.0,3.0,3.0,2.0,2.0,3.0,2.0,2.0,3.0
3.0,2.0,3.0,4.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,2.0,2.0,3.0,2.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0,3.0
2.0,3.0,3.0,2.0,3.0,3.0,4.0,4.0,3.0
3.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0
2.0,2.0,2.0,1.0,1.0,1.0,2.0,2.0,2.0
2.0,3.0,2.0,2.0,2.0,2.0,2.0,3.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,2.0,2.0,2.0,3.0,2.0,3.0
3.0,3.0,3.0,4.0,4.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,2.0,2.0,2.0,3.0,3.0,3.0
2.0,3.0,3.0,2.0,2.0,3.0,2.0,3.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,3.0,2.0
3.0,3.0,3.0,4.0,4.0,3.0,2.0,3.0,3.0
3.0,3.0,3.0,2.0,2.0,2.0,2.0,2.0,2.0
3.0,2.0,3.0,3.0,3.0,3.0,2.0,2.0,2.0
3.0,4.0,3.0,3.0,3.0,3.0,4.0,3.0,3.0
1.0,2.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,4.0,4.0,4.0
2.0,2.0,2.0,2.0,3.0,2.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,2.0
4.0,3.0,3.0,4.0,3.0,3.0,2.0,2.0,3.0
2.0,3.0,3.0,2.0,2.0,2.0,3.0,2.0,2.0
2.0,2.0,3.0,4.0,4.0,3.0,2.0,3.0,3.0
2.0,3.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0
3.0,3.0,3.0,2.0,2.0,3.0,2.0,2.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,2.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,4.0,3.0,3.0,3.0,3.0,4.0,3.0,4.0
2.0,3.0,3.0,2.0,2.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,4.0,3.0
2.0,2.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0,3.0
3.0,2.0,3.0,3.0,3.0,3.0,2.0,2.0,2.0
2.0,2.0,2.0,2.0,3.0,2.0,3.0,3.0,3.0
3.0,3.0,2.0,3.0,3.0,3.0,4.0,3.0,3.0
3.0,2.0,3.0,3.0,3.0,3.0,2.0,2.0,2.0
2.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
2.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
4.0,3.0,4.0,4.0,3.0,4.0,2.0,3.0,3.0
3.0,3.0,2.0,3.0,3.0,3.0,2.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,2.0,2.0,2.0,3.0
2.0,2.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
4.0,4.0,4.0,4.0,3.0,3.0,3.0,2.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
2.0,2.0,2.0,2.0,3.0,2.0,2.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,2.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,3.0,2.0
2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,2.0,3.0,2.0,2.0,3.0
2.0,2.0,2.0,4.0,4.0,4.0,3.0,3.0,3.0
3.0,3.0,3.0,2.0,2.0,2.0,3.0,2.0,2.0
4.0,3.0,3.0,2.0,2.0,3.0,2.0,2.0,2.0
2.0,2.0,2.0,3.0,3.0,3.0,1.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
2.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,2.0,2.0,2.0,2.0,2.0
2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0,2.0
3.0,2.0,3.0,3.0,2.0,2.0,2.0,2.0,2.0
3.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0
4.0,3.0,3.0,3.0,2.0,3.0,3.0,3.0,3.0
2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0
3.0,3.0,2.0,3.0,2.0,2.0,3.0,3.0,3.0
4.0,3.0,3.0,3.0,3.0,3.0,4.0,3.0,3.0
2.0,2.0,2.0,2.0,2.0,3.0,2.0,2.0,2.0
2.0,3.0,3.0,2.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0,3.0
2.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,2.0,3.0,2.0,2.0,2.0,2.0,1.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,3.0,3.0
2.0,2.0,2.0,1.0,2.0,2.0,3.0,2.0,3.0
2.0,2.0,2.0,2.0,2.0,2.0,3.0,2.0,2.0
3.0,3.0,3.0,2.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,2.0,3.0,3.0,3.0`

	r := csv.NewReader(strings.NewReader(csvData))
	recs, err := r.ReadAll()
	if err != nil {
		t.Fatalf("failed to read csv: %v", err)
	}
	header := recs[0]
	nVars := len(header)
	cols := make([][]float64, nVars)
	for i := 1; i < len(recs); i++ {
		row := recs[i]
		for j := 0; j < nVars; j++ {
			v, _ := strconv.ParseFloat(row[j], 64)
			cols[j] = append(cols[j], v)
		}
	}

	data := make([]*insyra.DataList, nVars)
	for j := 0; j < nVars; j++ {
		vals := make([]any, len(cols[j]))
		for i := range cols[j] {
			vals[i] = cols[j][i]
		}
		dl := insyra.NewDataList(vals...)
		dl.SetName(header[j])
		data[j] = dl
	}

	dt := insyra.NewDataTable(data...)

	opt := stats.FactorAnalysisOptions{
		Preprocess: stats.FactorPreprocessOptions{Standardize: true},
		Count:      stats.FactorCountSpec{Method: stats.FactorCountFixed, FixedK: 3},
		Extraction: stats.FactorExtractionPAF,
		Rotation:   stats.FactorRotationOptions{Method: stats.FactorRotationOblimin, Kappa: 4, Delta: 0},
		Scoring:    stats.FactorScoreNone,
		MaxIter:    1000,
		MinErr:     1e-9,
	}

	model := stats.FactorAnalysis(dt, opt)
	if model == nil {
		t.Fatalf("FactorAnalysis returned nil")
	}

	var rotmatDense, phiDense *mat.Dense
	if model.RotationMatrix != nil {
		model.RotationMatrix.AtomicDo(func(table *insyra.DataTable) {
			r, c := table.Size()
			m := mat.NewDense(r, c, nil)
			for i := 0; i < r; i++ {
				row := table.GetRow(i)
				for j := 0; j < c; j++ {
					v, _ := row.Get(j).(float64)
					m.Set(i, j, v)
				}
			}
			rotmatDense = m
		})
	}

	if model.Phi != nil {
		model.Phi.AtomicDo(func(table *insyra.DataTable) {
			r, c := table.Size()
			m := mat.NewDense(r, c, nil)
			for i := 0; i < r; i++ {
				row := table.GetRow(i)
				for j := 0; j < c; j++ {
					v, _ := row.Get(j).(float64)
					m.Set(i, j, v)
				}
			}
			phiDense = m
		})
	}

	// Check: rotmat * rotmat^T should equal Phi
	var rRt mat.Dense
	rRt.Mul(rotmatDense, rotmatDense.T())
	fmt.Println("\n=== Our rotmat * rotmat^T ===")
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			fmt.Printf("%10.6f ", rRt.At(i, j))
		}
		fmt.Println()
	}

	fmt.Println("\n=== Our Phi ===")
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			fmt.Printf("%10.6f ", phiDense.At(i, j))
		}
		fmt.Println()
	}

	fmt.Println("\n=== SPSS Target Rotmat ===")
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			fmt.Printf("%10.6f ", ref.Rotmat[i][j])
		}
		fmt.Println()
	}

	fmt.Println("\n=== Our Rotmat ===")
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			fmt.Printf("%10.6f ", rotmatDense.At(i, j))
		}
		fmt.Println()
	}

	fmt.Println("\n=== Difference ===")
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			diff := rotmatDense.At(i, j) - ref.Rotmat[i][j]
			fmt.Printf("%10.6f ", diff)
		}
		fmt.Println()
	}
}
