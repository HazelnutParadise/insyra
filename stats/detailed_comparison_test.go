package stats_test

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"math"
	"strconv"
	"strings"
	"testing"

	"github.com/HazelnutParadise/insyra"
	"github.com/HazelnutParadise/insyra/stats"
	"gonum.org/v1/gonum/mat"
)

func TestDetailedComparison(t *testing.T) {
	var spssTargetJSON = `{
	  "loadings": [
		[0.356343, 0.761905, -0.016447],
		[0.410697, 0.569859, 0.255471],
		[0.503369, 0.533348, 0.07185],
		[0.695961, 0.112845, -0.485805],
		[0.731736, -0.294728, -0.443574],
		[0.681167, -0.001737, -0.311898],
		[0.516291, -0.160115, 0.611136],
		[0.684009, -0.33903, 0.28828],
		[0.652246, -0.167228, 0.320202]
	  ],
	  "rotmat": [
		[0.987413, 0.149994, 0.050166],
		[-0.132469, 0.989933, -0.049839],
		[0.017541, -0.037383, -0.999147]
	  ],
	  "Phi": [
		[1.0, 0.015183, 0.03841],
		[0.015183, 1.0, -0.010466],
		[0.03841, -0.010466, 1.0]
	  ]
	}`

	type spssRef struct {
		Loadings [][]float64 `json:"loadings"`
		Rotmat   [][]float64 `json:"rotmat"`
		Phi      [][]float64 `json:"Phi"`
	}

	var ref spssRef
	json.Unmarshal([]byte(spssTargetJSON), &ref)

	csvData := `x1,x2,x3,x4,x5,x6,x7,x8,x9
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,2.0,2.0,2.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,4.0,3.0,4.0,3.0,3.0
3.0,2.0,3.0,3.0,4.0,3.0,2.0,3.0,2.0
3.0,3.0,3.0,3.0,4.0,3.0,3.0,3.0,3.0
4.0,3.0,3.0,2.0,2.0,2.0,3.0,2.0,2.0
3.0,3.0,3.0,2.0,2.0,3.0,2.0,2.0,3.0
3.0,2.0,3.0,4.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,2.0,2.0,3.0,2.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0,3.0
2.0,3.0,3.0,2.0,3.0,3.0,4.0,4.0,3.0
3.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0
2.0,2.0,2.0,1.0,1.0,1.0,2.0,2.0,2.0
2.0,3.0,2.0,2.0,2.0,2.0,2.0,3.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,2.0,2.0,2.0,3.0,2.0,3.0
3.0,3.0,3.0,4.0,4.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,2.0,2.0,2.0,3.0,3.0,3.0
2.0,3.0,3.0,2.0,2.0,3.0,2.0,3.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,3.0,2.0
3.0,3.0,3.0,4.0,4.0,3.0,2.0,3.0,3.0
3.0,3.0,3.0,2.0,2.0,2.0,2.0,2.0,2.0
3.0,2.0,3.0,3.0,3.0,3.0,2.0,2.0,2.0
3.0,4.0,3.0,3.0,3.0,3.0,4.0,3.0,3.0
1.0,2.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,4.0,4.0,4.0
2.0,2.0,2.0,2.0,3.0,2.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,2.0
4.0,3.0,3.0,4.0,3.0,3.0,2.0,2.0,3.0
2.0,3.0,3.0,2.0,2.0,2.0,3.0,2.0,2.0
2.0,2.0,3.0,4.0,4.0,3.0,2.0,3.0,3.0
2.0,3.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0
3.0,3.0,3.0,2.0,2.0,3.0,2.0,2.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,2.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,4.0,3.0,3.0,3.0,3.0,4.0,3.0,4.0
2.0,3.0,3.0,2.0,2.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,4.0,3.0
2.0,2.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0,3.0
3.0,2.0,3.0,3.0,3.0,3.0,2.0,2.0,2.0
2.0,2.0,2.0,2.0,3.0,2.0,3.0,3.0,3.0
3.0,3.0,2.0,3.0,3.0,3.0,4.0,3.0,3.0
3.0,2.0,3.0,3.0,3.0,3.0,2.0,2.0,2.0
2.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
2.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
4.0,3.0,4.0,4.0,3.0,4.0,2.0,3.0,3.0
3.0,3.0,2.0,3.0,3.0,3.0,2.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,2.0,2.0,2.0,3.0
2.0,2.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
4.0,4.0,4.0,4.0,3.0,3.0,3.0,2.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
2.0,2.0,2.0,2.0,3.0,2.0,2.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,2.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,3.0,2.0
2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,2.0,3.0,2.0,2.0,3.0
2.0,2.0,2.0,4.0,4.0,4.0,3.0,3.0,3.0
3.0,3.0,3.0,2.0,2.0,2.0,3.0,2.0,2.0
4.0,3.0,3.0,2.0,2.0,3.0,2.0,2.0,2.0
2.0,2.0,2.0,3.0,3.0,3.0,1.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
2.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,2.0,2.0,2.0,2.0,2.0
2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0,2.0
3.0,2.0,3.0,3.0,2.0,2.0,2.0,2.0,2.0
3.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0
4.0,3.0,3.0,3.0,2.0,3.0,3.0,3.0,3.0
2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0
3.0,3.0,2.0,3.0,2.0,2.0,3.0,3.0,3.0
4.0,3.0,3.0,3.0,3.0,3.0,4.0,3.0,3.0
2.0,2.0,2.0,2.0,2.0,3.0,2.0,2.0,2.0
2.0,3.0,3.0,2.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0,3.0
2.0,2.0,2.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,2.0,3.0,2.0,2.0,2.0,2.0,1.0
3.0,3.0,3.0,3.0,3.0,3.0,2.0,3.0,3.0
2.0,2.0,2.0,1.0,2.0,2.0,3.0,2.0,3.0
2.0,2.0,2.0,2.0,2.0,2.0,3.0,2.0,2.0
3.0,3.0,3.0,2.0,3.0,3.0,3.0,3.0,3.0
3.0,3.0,3.0,3.0,3.0,3.0,3.0,2.0,2.0
3.0,3.0,3.0,3.0,3.0,2.0,3.0,3.0,3.0`

	r := csv.NewReader(strings.NewReader(csvData))
	recs, _ := r.ReadAll()
	header := recs[0]
	nVars := len(header)
	cols := make([][]float64, nVars)
	for i := 1; i < len(recs); i++ {
		row := recs[i]
		for j := 0; j < nVars; j++ {
			v, _ := strconv.ParseFloat(row[j], 64)
			cols[j] = append(cols[j], v)
		}
	}

	data := make([]*insyra.DataList, nVars)
	for j := 0; j < nVars; j++ {
		vals := make([]any, len(cols[j]))
		for i := range cols[j] {
			vals[i] = cols[j][i]
		}
		dl := insyra.NewDataList(vals...)
		dl.SetName(header[j])
		data[j] = dl
	}

	dt := insyra.NewDataTable(data...)

	opt := stats.FactorAnalysisOptions{
		Preprocess: stats.FactorPreprocessOptions{Standardize: true},
		Count:      stats.FactorCountSpec{Method: stats.FactorCountFixed, FixedK: 3},
		Extraction: stats.FactorExtractionPAF,
		Rotation:   stats.FactorRotationOptions{Method: stats.FactorRotationOblimin, Kappa: 4, Delta: 0},
		Scoring:    stats.FactorScoreNone,
		MaxIter:    1000,
		MinErr:     1e-9,
	}

	model := stats.FactorAnalysis(dt, opt)

	var loadingsDense *mat.Dense
	model.Loadings.AtomicDo(func(table *insyra.DataTable) {
		r, c := table.Size()
		m := mat.NewDense(r, c, nil)
		for i := 0; i < r; i++ {
			row := table.GetRow(i)
			for j := 0; j < c; j++ {
				v, _ := row.Get(j).(float64)
				m.Set(i, j, v)
			}
		}
		loadingsDense = m
	})

	// Compare Loadings element by element
	fmt.Println("\n=== Loadings Comparison (First 3 rows) ===")
	fmt.Println("        SPSS                  Ours                  Difference")
	for i := 0; i < 3; i++ {
		fmt.Printf("Row %d:\n", i+1)
		for j := 0; j < 3; j++ {
			spss := ref.Loadings[i][j]
			ours := loadingsDense.At(i, j)
			diff := ours - spss
			fmt.Printf("  F%d: %10.6f  vs  %10.6f  (diff: %+.6f)\n", j+1, spss, ours, diff)
		}
	}

	// Find max error location in loadings
	maxErr := 0.0
	maxI, maxJ := 0, 0
	for i := 0; i < 9; i++ {
		for j := 0; j < 3; j++ {
			diff := math.Abs(loadingsDense.At(i, j) - ref.Loadings[i][j])
			if diff > maxErr {
				maxErr = diff
				maxI, maxJ = i, j
			}
		}
	}
	fmt.Printf("\n=== Max Loadings Error: %.6f at [%d,%d] ===\n", maxErr, maxI, maxJ)
	fmt.Printf("SPSS: %.6f, Ours: %.6f\n", ref.Loadings[maxI][maxJ], loadingsDense.At(maxI, maxJ))

	// Check if factors need sign flip
	fmt.Println("\n=== Factor Correlation Analysis ===")
	for j := 0; j < 3; j++ {
		corr := 0.0
		for i := 0; i < 9; i++ {
			corr += ref.Loadings[i][j] * loadingsDense.At(i, j)
		}
		fmt.Printf("Factor %d correlation: %.6f\n", j+1, corr)
	}
}
